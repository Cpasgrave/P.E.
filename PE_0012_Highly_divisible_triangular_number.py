"""
Highly divisible triangular number

The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
"""

def primesTo(n):
    sieve=[1]*(n+1)
    primes = []
    for m in range(2,n+1):
        if sieve[m]:
            primes += [m]
            for j in range(m*m,n+1,m): sieve[j]=0
    return primes


primes = primesTo(500000)
primeset = set(primes)
cache = {}

# this prime decomposition is specially designed here to take advantage
# of the cache. Any sub-divizor of n will be stored in cache and 
# can be reused for another n having this subdivizor.
def primeDec(n):

    if n in cache: return cache[n]
    dec = {}
    div = 1
    i = 0
    while True:

        p = primes[i]
        while n%p==0:
            dec[p] = dec.get(p,0)+1
            n //= p
            div *= p
            if n in cache:
                for k,v in cache[n].items():
                    dec[k] = dec.get(k,0)+v
                return dec
            else:
                cache[div] = dict(dec)
        if n in primeset:
            dec[n] = 1
            break
        elif n==1: break
        i += 1
    return dec


def euler_12(target):

    factors = {}
    prev = {}

    n = 0
    even = True

    while True:

        n += 1
        even = not even

        pd = {}
        if even:
            pd.update(prev)
            prev = primeDec(n+1)
            for k,v in prev.items():
                pd[k] = pd.get(k,0)+v
        else:
            pd.update(prev)
            prev = primeDec((n+1)//2)
            for k,v in prev.items():
                pd[k] = pd.get(k,0)+v

        n_div = 1
        for k,v in pd.items(): n_div *= v+1
        if n_div>target: return n*(n+1)//2
 

from time import perf_counter as tm
target = 2000

t = tm()
e12 = euler_12(target)
print(e12)
print(tm()-t)
print()

"""
N = n*(n+1)//2
Donc la d√©composition en facteurs premiers de N : dp(N)
si n est pair:
    dp(N) = dp(n/2) * dp(n+1)
sinon:
    dp(N) = dp(n) * dp((n+1)/2)
""" 

# Project Euler site version:
def tri(target):
    n = 3
    dn = 2
    ct = 0
    primes = primesTo(target)
    while ct<target:
        n += 1
        n1 = n
        if n1%2==0: n1 = n1//2
        dn1 = 1
        for p in primes:
            if p**2>n1:
                dn1*=2
                break
            exponent = 1
            while n1%p==0:
                exponent += 1
                n1 //= p
            if exponent>1: dn1*=exponent
            if n1==1: break
        ct = dn*dn1
        dn = dn1
    return n*(n-1)/2

t = tm()
tt = tri(target)
print(tt)
print(tm()-t)